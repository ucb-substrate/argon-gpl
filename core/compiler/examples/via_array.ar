fn max(x0: Float, x1: Float) -> Float {
  if x0 < x1 {
    x1
  } else {
    x0
  }
}

fn min(x0: Float, x1: Float) -> Float {
  if x0 < x1 {
    x0
  } else {
    x1
  }
}

fn intersection(rect1: Rect, rect2: Rect) -> Rect {
    let intersection_x0 = max(rect1.x0, rect2.x0);
    let intersection_y0 = max(rect1.y0, rect2.y0);
    let intersection_x1 = min(rect1.x1, rect2.x1);
    let intersection_y1 = min(rect1.y1, rect2.y1);
    crect(x0=intersection_x0, y0=intersection_y0, x1=intersection_x1, y1=intersection_y1)
}

fn bbox(rect1: Rect, rect2: Rect) -> Rect {
    let bbox_x0 = min(rect1.x0, rect2.x0);
    let bbox_y0 = min(rect1.y0, rect2.y0);
    let bbox_x1 = max(rect1.x1, rect2.x1);
    let bbox_y1 = max(rect1.y1, rect2.y1);
    crect(x0=bbox_x0, y0=bbox_y0, x1=bbox_x1, y1=bbox_y1)
}

fn array(r: Rect, n: Int, xpitch: Float, ypitch: Float) -> Rect {
    if n == 1 {
        let first_rect = rect(r.layer)!;
        eq(first_rect.w, r.w);
        eq(first_rect.h, r.h);
        first_rect
    } else {
        let subarray = array(r, n - 1, xpitch, ypitch);
        let first_rect = rect(r.layer)!;
        eq(first_rect.w, r.w);
        eq(first_rect.h, r.h);
        eq(first_rect.x0 + xpitch, subarray.x0);
        eq(first_rect.y0 + ypitch, subarray.y0);
        let out_rect = crect();
        if xpitch > 0. {
            eq(out_rect.x0, first_rect.x0);
            eq(out_rect.x1, subarray.x1);
        } else {
            eq(out_rect.x0, subarray.x0);
            eq(out_rect.x1, first_rect.x1);
        }
        if ypitch > 0. {
            eq(out_rect.y0, first_rect.y0);
            eq(out_rect.y1, subarray.y1);
        } else {
            eq(out_rect.y0, subarray.y0);
            eq(out_rect.y1, first_rect.y1);
        }
        out_rect
    }
}

fn array2(r: Rect, nx: Int, ny: Int, xpitch: Float, ypitch: Float) -> Rect {
    if ny == 1 {
        array(r, nx, xpitch, 0.)
    } else {
        let subarray = array2(r, nx, ny-1, xpitch, ypitch);
        let first_rect = array(r, nx, xpitch, 0.);
        eq(first_rect.x0, subarray.x0);
        eq(first_rect.y0 + ypitch, subarray.y0);
        let out_rect = crect();
        eq(out_rect.x0, first_rect.x0);
        eq(out_rect.x1, first_rect.x1);
        if ypitch > 0. {
            eq(out_rect.y0, first_rect.y0);
            eq(out_rect.y1, subarray.y1);
        } else {
            eq(out_rect.y0, subarray.y0);
            eq(out_rect.y1, first_rect.y1);
        }
        out_rect
    }
}

fn max_array(r: Rect, w: Float, h: Float, xpitch: Float, ypitch: Float) -> Rect {
    let nx = (((w - r.w) / xpitch) as Int + 1);
    let ny = (((h - r.h) / ypitch) as Int + 1);
    array2(r, nx, ny, xpitch, ypitch)
}

cell vias() {
    let met2 = rect(Layer::Met2)!;
    let met1 = rect(Layer::Met1)!;

    // Create via.
    let via = rect(Layer::Via1);
    eq(via.w, 10.);
    eq(via.h, 10.);
    eq(via.x0, 0.);
    eq(via.y0, 0.);
    let intersection = intersection(met1, met2);
    let via_array = max_array(via, intersection.w, intersection.h, 20., 20.);
    eq(via_array.x0 - intersection.x0, intersection.x1 - via_array.x1);
    eq(via_array.y0 - intersection.y0, intersection.y1 - via_array.y1);

    // Constrain metals.
    eq(met2.x0, 0.);
    eq(met2.y0, 0.);
    eq(met2.x1, 100.);
    eq(met2.y1, 100.);
    eq(met1.x0, 5.);
    eq(met1.y0, 5.);
    eq(met1.x1, 95.);
    eq(met1.y1, 95.);
}
