use std::net::{IpAddr, Ipv6Addr, SocketAddr};

use async_compat::CompatExt;
use futures::{future, prelude::*};
use gpui::{BackgroundExecutor, ForegroundExecutor};
use lsp_server::rpc::{GuiToLspClient, LspToGui};
use portpicker::pick_unused_port;
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};

pub struct SyncGuiToLspClient {
    executor: BackgroundExecutor,
    client: GuiToLspClient,
}

impl SyncGuiToLspClient {
    pub fn new(executor: BackgroundExecutor, lsp_addr: SocketAddr) -> Self {
        let client = executor.block(
            async move {
                let mut transport = tarpc::serde_transport::tcp::connect(lsp_addr, Json::default);
                transport.config_mut().max_frame_length(usize::MAX);

                GuiToLspClient::new(tarpc::client::Config::default(), transport.await.unwrap())
                    .spawn()
            }
            .compat(),
        );
        let port = loop {
            if let Some(port) = pick_unused_port() {
                break port;
            }
        };
        let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), port).into();
        let executor_clone = executor.clone();
        executor
            .spawn(
                async move {
                    let mut listener =
                        tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
                            .await
                            .unwrap();
                    listener.config_mut().max_frame_length(usize::MAX);
                    listener
                        // Ignore accept errors.
                        .filter_map(|r| futures::future::ready(r.ok()))
                        .map(tarpc::server::BaseChannel::with_defaults)
                        // Limit channels to 1 per IP.
                        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                        // serve is generated by the service attribute. It takes as input any type implementing
                        // the generated World trait.
                        .map(|channel| {
                            let server = GuiServer;
                            channel
                                .execute(server.serve())
                                .for_each(|t| executor_clone.spawn(t))
                        })
                        // Max 10 channels.
                        .buffer_unordered(10)
                        .for_each(|_| async {})
                        .await;
                }
                .compat(),
            )
            .detach();
        let client_clone = client.clone();
        executor.block(
            async move {
                client_clone
                    .register(context::current(), server_addr)
                    .await
                    .unwrap()
            }
            .compat(),
        );
        Self { executor, client }
    }
}

#[derive(Clone)]
pub struct GuiServer;

impl LspToGui for GuiServer {
    async fn bye(self, _: context::Context, name: String) -> String {
        format!("Bye, {name}!")
    }
}
