use std::{
    net::{IpAddr, Ipv6Addr, SocketAddr},
    path::PathBuf,
};

use async_compat::CompatExt;
use cfgrammar::Span;
use compiler::compile::{BasicRect, CompileOutput};
use futures::{
    channel::mpsc::{self, Sender},
    prelude::*,
};
use gpui::{AsyncApp, Context, Entity};
use lsp_server::rpc::{GuiToLspClient, LspToGui};
use portpicker::pick_unused_port;
use tarpc::{
    context,
    server::{Channel, incoming::Incoming},
    tokio_serde::formats::Json,
};

use crate::editor::EditorState;

#[derive(Clone)]
pub struct SyncGuiToLspClient {
    app: AsyncApp,
    client: GuiToLspClient,
}

impl SyncGuiToLspClient {
    pub fn new(app: AsyncApp, lsp_addr: SocketAddr) -> Self {
        let client = app.background_executor().block(
            async move {
                let mut transport = tarpc::serde_transport::tcp::connect(lsp_addr, Json::default);
                transport.config_mut().max_frame_length(usize::MAX);

                GuiToLspClient::new(tarpc::client::Config::default(), transport.await.unwrap())
                    .spawn()
            }
            .compat(),
        );
        Self { app, client }
    }

    pub fn register_server(&self, state: Entity<EditorState>) {
        let port = loop {
            if let Some(port) = pick_unused_port() {
                break port;
            }
        };
        let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), port).into();
        let background_executor = self.app.background_executor().clone();
        let (tx, mut rx) = mpsc::channel(1);
        self.app
            .background_executor()
            .spawn(
                async move {
                    let mut listener =
                        tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
                            .await
                            .unwrap();
                    listener.config_mut().max_frame_length(usize::MAX);
                    listener
                        // Ignore accept errors.
                        .filter_map(|r| futures::future::ready(r.ok()))
                        .map(tarpc::server::BaseChannel::with_defaults)
                        // Limit channels to 1 per IP.
                        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
                        // serve is generated by the service attribute. It takes as input any type implementing
                        // the generated World trait.
                        .map(|channel| {
                            let server = GuiServer {
                                to_exec: tx.clone(),
                            };
                            channel
                                .execute(server.serve())
                                .for_each(|t| background_executor.spawn(t))
                        })
                        // Max 10 channels.
                        .buffer_unordered(10)
                        .for_each(|_| async {})
                        .await;
                }
                .compat(),
            )
            .detach();
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .register(context::current(), server_addr)
                    .await
                    .unwrap()
            }
            .compat(),
        );
        self.app
            .spawn(async move |app| {
                loop {
                    if let Some(exec) = rx.next().await {
                        state
                            .update(app, |state, cx| {
                                exec(state, cx);
                            })
                            .unwrap();
                    }
                }
            })
            .detach();
    }

    // TODO: Improve API.
    pub fn select_rect(&self, span: Option<(PathBuf, Span)>) {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .select_rect(context::current(), span)
                    .await
                    .unwrap()
            }
            .compat(),
        );
    }

    // TODO: Improve API.
    pub fn draw_rect(
        &self,
        file: PathBuf,
        scope_span: Span,
        var_name: String,
        rect: BasicRect<f64>,
    ) {
        let client_clone = self.client.clone();
        self.app.background_executor().block(
            async move {
                client_clone
                    .draw_rect(context::current(), file, scope_span, var_name, rect)
                    .await
                    .unwrap()
            }
            .compat(),
        );
    }
}

type StateMutFn = Box<dyn FnOnce(&mut EditorState, &mut Context<EditorState>) + Send>;

#[derive(Clone)]
pub struct GuiServer {
    to_exec: Sender<StateMutFn>,
}

impl LspToGui for GuiServer {
    async fn open_cell(mut self, _: context::Context, file: PathBuf, cell: CompileOutput) {
        self.to_exec
            .send(Box::new(|state, cx| {
                state.update(cx, file, cell);
                cx.notify();
            }))
            .await
            .unwrap();
    }
    async fn set(mut self, _: tarpc::context::Context, key: String, value: String) -> () {
        match key.as_str() {
            "hierarchyDepth" => {
                self.to_exec
                    .send(Box::new(move |state, cx| {
                        // TODO: Need better way to specify infinite hierarchy depth.
                        state.hierarchy_depth = value.parse().unwrap_or(usize::MAX);
                        cx.notify();
                    }))
                    .await
                    .unwrap();
            }
            _ => {
                // TODO: handle errors.
            }
        }
    }
}
